<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.53">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>analysis – Raven Back Trajectories</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Raven Back Trajectories</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
    <div class="dropdown">
      <a href="" title="" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label=""><i class="bi bi-github"></i></a>
      <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://github.com/Troll-Observing-Network/integrated-cloud-observatory-team/">
            Source Code
            </a>
          </li>
      </ul>
    </div>
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    <div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="analysis.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="analysis" class="level1 unnumbered">
<h1 class="unnumbered">Analysis</h1>
<section id="ideas-for-analysis" class="level2">
<h2 class="anchored" data-anchor-id="ideas-for-analysis">Ideas for analysis</h2>
<ul>
<li><p><strong>Diabatic vs adiabatic heating/cooling</strong></p></li>
<li><p><strong>Moisture uptake</strong></p></li>
</ul>
<p>This method comes from <span class="citation" data-cites="sodemannInterannualVariabilityGreenland2008">Sodemann, Schwierz, and Wernli (<a href="#ref-sodemannInterannualVariabilityGreenland2008" role="doc-biblioref">2008</a>)</span>; they cite <span class="citation" data-cites="jamesClimatologicalAspectsExtreme2004">James et al. (<a href="#ref-jamesClimatologicalAspectsExtreme2004" role="doc-biblioref">2004</a>)</span>. One simply calculates the change in specific humidity between equally spaced periods along the trajectory.</p>
<ul>
<li><strong>Moisture Source Attribution</strong></li>
</ul>
<p>This method comes from <span class="citation" data-cites="sodemannInterannualVariabilityGreenland2008">Sodemann, Schwierz, and Wernli (<a href="#ref-sodemannInterannualVariabilityGreenland2008" role="doc-biblioref">2008</a>)</span>.</p>
<p>I think it might be interesting to plot symbols on the trajectory map that show moisture uptake (<font color="blue">blue</font> = evaporation) and moisture loss (<font color="red">blue</font> = precipitation; color represent gain and loss to the atmosphere). <em>Think about color choices here…</em></p>
<ul>
<li><strong>Associate trajectory with cloud base height</strong></li>
</ul>
<p>Determine the cloud-base height at each trajectory time. (This can be done using the CL61 summary files at 15 minute resolution.) Then select the vertical level that is closest to the cloud-base height. Plot all of these trajectories together to determine if they might be categorized. Determine the SOMs that are associated with the resulting categories; see below.</p>
<ul>
<li><strong>Associate trajectory with Self Organizing Map</strong></li>
</ul>
<p>Determine the SOMs that are associated with each near-surface trajectory. I suspect that some SOMs will the associated with precipitation along the trajectory and some won’t.</p>
<ul>
<li><strong>Regional trajectory analysis</strong></li>
</ul>
<p>Use the methods of <span class="citation" data-cites="hermannLagrangianAnalysisDynamical2020">Hermann, Papritz, and Wernli (<a href="#ref-hermannLagrangianAnalysisDynamical2020" role="doc-biblioref">2020</a>)</span> to analyze multiple trajectories across the SW region of Greenland for the summer of 2024 to investigate how representative the SLEIGH measurements are. A lot of cool research questions here:</p>
<ul>
<li>How large of an area in SW Greenland if affected by similar conditions to Raven?</li>
<li>How representative are the SLEIGH measurments under different atmospheric conditions (SOMs)?</li>
</ul>
</section>
<section id="ideas-for-plots" class="level2">
<h2 class="anchored" data-anchor-id="ideas-for-plots">Ideas for plots</h2>
<ul>
<li><p>Plot an individual trajectory in the context of ALL the trajectories at a given vertical level for the Raven 2024 field season. All the trajectories would use a very think line, while the desired trajectory would me bold and thick. Similar to Figure 2 in <span class="citation" data-cites="hermannLagrangianAnalysisDynamical2020">Hermann, Papritz, and Wernli (<a href="#ref-hermannLagrangianAnalysisDynamical2020" role="doc-biblioref">2020</a>)</span>.</p></li>
<li><p>Plot time series of an individual trajectory in the context of ALL the trajectories at a given vertical level for the Raven 2024 field season. Use shading to show the upper and lower quartiles and upper and lower deciles. Similar to Figures 2, 3, 5, 6, 7, 8 in <span class="citation" data-cites="bieliLagrangianInvestigationHot2015">Bieli, Pfahl, and Wernli (<a href="#ref-bieliLagrangianInvestigationHot2015" role="doc-biblioref">2015</a>)</span>.</p></li>
<li><p>Create potential temperature (theta) vs air temperature (T) plots. Add lines of constant pressure. Similar to Figure 10 of <span class="citation" data-cites="bieliLagrangianInvestigationHot2015">Bieli, Pfahl, and Wernli (<a href="#ref-bieliLagrangianInvestigationHot2015" role="doc-biblioref">2015</a>)</span> and Figure 10 of <span class="citation" data-cites="hermannLagrangianAnalysisDynamical2020">Hermann, Papritz, and Wernli (<a href="#ref-hermannLagrangianAnalysisDynamical2020" role="doc-biblioref">2020</a>)</span>. (Note that Hermann plotted T vs theta instead of theta vs T).</p></li>
</ul>
</section>
<section id="useful-equations" class="level2">
<h2 class="anchored" data-anchor-id="useful-equations">Useful equations</h2>
<section id="diabatic-versus-adiabatic-changes" class="level3">
<h3 class="anchored" data-anchor-id="diabatic-versus-adiabatic-changes">Diabatic versus Adiabatic changes</h3>
<p><span class="math display">\[
\frac{dT}{dt} = \frac{\kappa T \omega}{p} + H \left( \frac{p_o}{p} \right)^{-\kappa}
\]</span></p>
<ul>
<li>the first term on the right represents the adiabatic heating/cooling from compression/expansion. <span class="math inline">\(\omega\)</span> &gt; 0 for <em>descending</em> motion (compression and heating, + term).</li>
<li>the second term on the right represents diabatic temperature changes from latent heating in clouds (rare at the surface), radiation, and surface fluxes. Therefore, the term H can be written as <span class="math inline">\(H = H_{cld} + H_{rad} + H_{sfl}\)</span>.</li>
</ul>
</section>
<section id="changes-in-moisture-content" class="level3">
<h3 class="anchored" data-anchor-id="changes-in-moisture-content">Changes in Moisture Content</h3>
<p><span class="math display">\[
\frac{dq}{dt} \approx \frac{\Delta q}{\Delta t} = E - P = Evaporation - Precipitation \space [units: g \space kg^{-1} \space (1 h)^{-1}]
\]</span></p>
<ul>
<li>Thus, changes in the air parcel’s moisture content can be approximated by simply determing the change in q (specific humidity) between each time step (because each time step is equal; 1 hour).</li>
</ul>
</section>
<section id="air-parcel-velocity" class="level3">
<h3 class="anchored" data-anchor-id="air-parcel-velocity">Air Parcel Velocity</h3>
<p><span class="math display">\[
\frac{d \textbf{x}}{dt} = \textbf{u(x)}
\]</span></p>
</section>
</section>
<section id="plot-ideas" class="level2">
<h2 class="anchored" data-anchor-id="plot-ideas">Plot ideas</h2>
<ul>
<li><span class="math inline">\(\Theta\)</span> vs.&nbsp;T
<ul>
<li>T changes while <span class="math inline">\(\Theta\)</span> remains constant = adiabatic contribution</li>
<li>T and <span class="math inline">\(\Theta\)</span> change in parallel = diabatic contribution</li>
</ul></li>
<li>Trajectory time series showing median value and interquartile and interdecile ranges of:
<ul>
<li>q</li>
<li><span class="math inline">\(\Theta '\)</span></li>
<li>lat - lat_0</li>
<li>p</li>
<li>T - To</li>
<li><span class="math inline">\(\Theta - \Theta_o\)</span></li>
</ul></li>
</ul>



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-bieliLagrangianInvestigationHot2015" class="csl-entry" role="listitem">
Bieli, Melanie, Stephan Pfahl, and Heini Wernli. 2015. <span>“A <span>Lagrangian</span> Investigation of Hot and Cold Temperature Extremes in <span>Europe</span>.”</span> <em>Quarterly Journal of the Royal Meteorological Society</em> 141 (686): 98–108. <a href="https://doi.org/10.1002/qj.2339">https://doi.org/10.1002/qj.2339</a>.
</div>
<div id="ref-hermannLagrangianAnalysisDynamical2020" class="csl-entry" role="listitem">
Hermann, Mauro, Lukas Papritz, and Heini Wernli. 2020. <span>“A <span>Lagrangian</span> Analysis of the Dynamical and Thermodynamic Drivers of Large-Scale <span>Greenland</span> Melt Events During 1979–2017.”</span> <em>Weather and Climate Dynamics</em> 1 (2): 497–518. <a href="https://doi.org/10.5194/wcd-1-497-2020">https://doi.org/10.5194/wcd-1-497-2020</a>.
</div>
<div id="ref-jamesClimatologicalAspectsExtreme2004" class="csl-entry" role="listitem">
James, P., A. Stohl, N. Spichtinger, S. Eckhardt, and C. Forster. 2004. <span>“Climatological Aspects of the Extreme <span>European</span> Rainfall of <span>August</span> 2002 and a Trajectory Method for Estimating the Associated Evaporative Source Regions.”</span> <em>Natural Hazards and Earth System Sciences</em> 4 (5/6): 733–46. <a href="https://doi.org/10.5194/nhess-4-733-2004">https://doi.org/10.5194/nhess-4-733-2004</a>.
</div>
<div id="ref-sodemannInterannualVariabilityGreenland2008" class="csl-entry" role="listitem">
Sodemann, H., C. Schwierz, and H. Wernli. 2008. <span>“Interannual Variability of <span>Greenland</span> Winter Precipitation Sources: <span>Lagrangian</span> Moisture Diagnostic and <span>North Atlantic Oscillation</span> Influence.”</span> <em>Journal of Geophysical Research: Atmospheres</em> 113 (D3). <a href="https://doi.org/10.1029/2007JD008503">https://doi.org/10.1029/2007JD008503</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>